---
title: "Winning at work with R and the Tidyverse"
author: "Miles McBain"
date: "4 February 2017"
output: 
    ioslides_presentation:
        css: ./style.css
---

```{r setup, include=FALSE}
library(tidyverse)
library(broom)
library(knitr)
library(here)
library(devtools)
library(modelr)
COURSE_HOME <- here()
```

##Advanced Tidyverse Data Structures
Overview: In this session we introduce advanced `tidyr`, `purrr`, `broom`, `modelr`. 

We introduce advanced programming tools for building and manipulating tidy data followed by the application of those tools in a tidy modelling framework.


#Purrr

##List Programming
`purrr` is the Tidyverse answer to the `apply` family from base R. It contains an array of tools to make applying functions to lists, vectors, and dataframes clear and fit with other tasks in the tidyverse.

* The `map()` family are similar to `apply()` but gives you explicit control of the returned data structure. 

Examples:
```{r, eval=FALSE}
airquality %>%
    map(is.na)

airquality %>%
    map_df(is.na)
```

##Formula syntax
Function prototypes can be provided to `map()` with a formula syntax, creating a function prototype that is easy to read. 

`.x` Is the where the list elements are placed in the function call.

```{r, eval=FALSE}
list(low = 1, med = 1.5, high = 2) %>%
    map(~rnorm(mean = 0, sd = .x, n=100))
```

Exercise: (1.) Plot the densities of the sampled distributions overlaid in ggplot2.

##Map + Mutate
The control of return type, `map()` makes it very powerful in combination with `dplyr::mutate()`. In this example we want to find out how many dependencies each of the tidyverse packages have on CRAN.

```{r, eval=FALSE}

source(file.path(COURSE_HOME,"R/tidypacks.R"))

deps_df <- 
    tidypacks %>%
    mutate(dependent_packs = map(package, revdep)) 
#could take a minute to run.
```

What are the contents of the `dependent_packs` column?

##Exercise: Exclude Tidyverse Packages From Count
How can we remove all packages in Tidyverse from each list in the `dependent_packs` column?

Exercise: (2.) Calculate the number of depenencies on CRAN for each tidyverse package, exlcuding those in the tidyverse.

Hint: Dplyr has some funcitons for set operations.

```{r, eval=FALSE}
deps_df_no_tidy <-
    deps_df %>%
    mutate(dependent_packs = 
```

##Map/Reduce
`purrr` also provides a reduce function to summarise lists/vectors.

For example:
```{r, eval=FALSE}
list(1,2,3,4) %>% reduce(`*`)

#equivalent to

(((1 * 2) * 3) * 4)
#OR
`*`(`*`(`*`(1,2), 3), 4)
```

##Exercise: Calculate the Total CRAN packages that Depend on the Tidyverse.

(3.) Using `reduce` we can avoid double counting and find the total number of CRAN packages that depend on one or more tidyverse packages.

```{r, eval=FALSE}
deps_df_no_tidy %>%
```


##Other purrr features: Indexing lists
```{r, eval=FALSE}
geo_data <- tribble(
    ~location, ~coord,
          "A", list(x = 0, y = 1),
          "B", list(x = 1, y = 0),
          "C", list(x = -1, y = -1)
)

geo_data %>%
    mutate(x = map_dbl(coord, "x"),
           y = map_dbl(coord, "y")) %>%
    select(-coord)

```


##Exercise: Why doesn't this work?
What are we trying to do and why doesn't it work?
```{r, eval=FALSE}
geo_data %>%
    mutate(max_coord = map_dbl(coord, max)) %>%
    select(-coord)
```


##Final Remarks on Purrr
`purrr` is powerful tool for building Tidy Data from raw materials. Unfortunately its documentation is very brief. Examples are the best way to learn. We will see some further examples in this session.

For a great collection of examples see: [https://jennybc.github.io/purrr-tutorial/index.html](https://jennybc.github.io/purrr-tutorial/index.html)
    - [Talk by Jenny Bryan](https://www.youtube.com/watch?v=GapSskrtUzU])


#Advanced Tidyr 

##Nesting and Unnesting
`tidyr` can be used to create columns of nested tibbles. Yes - tibble columns can contain tibbles! 

[](./figs/nesting.jpg)

##Nesting and Unnesting: How?
Sometimes it's easier to say what you want to leave out of the nesting:

```{r, eval=FALSE}
mpg %>% nest(-year) # nest all columns other than year.

#or

mpg %>%
    group_by(year) %>%
    nest() # nest according to groups 
```

##Nesting and Unnesting: Why?
You can use `map` a funciton to a whole nested `tibble` using `dplyr` verbs:
```{r, eval=FALSE}
mpg_years <-
    mpg %>%
    group_by(year) %>%
    nest() %>%
    mutate(lm_model = map(data, 
                       ~lm(formula = cty ~ displ + cyl + manufacturer, .x)),
           coefs = map(lm_model, "coefficients"))

mpg_years$coefs
```

Can you think of other functions you might use in this way?

##Unnesting
`unnest` performs the reverse of nest. It only works with nested *tibbles or vectors, not lists*.

```{r, eval=FALSE}
mpg_years %>%
    ungroup() %>%
    unnest(data, .drop = FALSE) %>% View()

#by default .drop = TRUE. 
#Anything that would have to be duplicated will get dropped.
```

What gets dropped if `.drop = TRUE`?

##Exercsise: Leveraging unnest

(4.) With `geo_data` defined earlier, use `unnest` to explode the nested `x` and `y` coordinates into new columns.

```{r, eval=FALSE}
geo_data %>%
```

(5.) **Challenge!:** Use the same approach to arrive at:
```{r, eval=FALSE}
source(file.path(COURSE_HOME,"R/mpg_yrs_tidy.R"))
mpg_yrs_tidy
```

##Nesting + Dplyr + Purrr 
Nesting data within lists allows us to use `dplyr` + `purrr` to process it and **keep the results within a data frame**.  

But the code from (5.) is not really clear or tidy... there is a better way.


#Tidy Models

## Hello old friend | A linear model (logistic regression) {.codefont}
```{r, echo=FALSE, message=FALSE}
titanic_data <- read_csv(file.path(COURSE_HOME,"data/train.csv"))
```
```{r, echo=FALSE}
logistic_fit <- glm(data = titanic_data,
            formula = Survived ~ Age + Sex + Pclass,
            family=binomial(link = "logit")
   )
summary(logistic_fit)
```

##Tidy Models with Broom
`broom` is a package for creating tidy data frames model of output.
* tidy data means complete freedom in plotting and analysis of model diagnostics


##Augment data with diagnostics
`augment()` puts model diagnostics along side data

* great for exploring model fit with plots.
```{r, eval=FALSE}
aug_model <- augment(logistic_fit, type.predict = "response")
ggplot(aug_model) +
    geom_bar( mapping = aes(x = 1:nrow(aug_model), y = .cooksd), stat = "identity")
```

* How would we find the high leverage points in the above plot?

##Convert a model to tidy data
`tidy()` creates a tidy version of `summary()`
```{r}
tidy_logistic_fit <- tidy(logistic_fit)
```

##Exercise
(1.) Reproduce this plot for the effects from the `tidy()` output:
![](./figs/effect_plot.png)

##Exercise
Starter Code:
```{r, eval=FALSE}
tidy_logistic_fit %>%
  filter( term != "(Intercept)") %>%        
  mutate(effect.lwr_ci = exp(estimate - 2*std.error),
         effect = exp(estimate),
         effect.upr_ci = exp(estimate + 2*std.error)) %>%
  ggplot()
```


##Model -> One Row
* `glance()` creates a data frame with a 1 row summary
    - The strength of this becomes apparent when comparing *many* models
```{r}
glance(logistic_fit)
```

#Modelr

##Tidy Modelling
* `modelr` is a new way to look at fitting and evaluating sets of models.
* It provides facilities for creating training, test and cv datasets in tidy data frames

#K-fold-CV
```{r}
titanic_cv_data <-
    titanic_data %>%
    crossv_kfold(k = 3)
```

#broom::inflate
